import { GoogleGenerativeAI } from '@google/generative-ai';
import dotenv from 'dotenv';

dotenv.config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

/**
 * Generate a deliverable using Google Gemini AI
 * @param {Object} deliverableData - Data for generating the deliverable
 * @returns {Promise<string>} - Generated content
 */
export const generateDeliverable = async (deliverableData) => {
    const {
        deliverableName,
        deliverableType,
        templateContent,
        projectData,
        phaseData
    } = deliverableData;

    try {
        const model = genAI.getGenerativeModel({ model: 'gemini-pro' });

        const prompt = buildPrompt({
            deliverableName,
            deliverableType,
            templateContent,
            projectData,
            phaseData
        });

        const result = await model.generateContent(prompt);
        const response = await result.response;
        const generatedText = response.text();

        return generatedText;
    } catch (error) {
        console.error('AI generation error:', error);
        throw new Error(`Failed to generate deliverable: ${error.message}`);
    }
};

/**
 * Build a structured prompt for deliverable generation
 */
const buildPrompt = ({ deliverableName, deliverableType, templateContent, projectData, phaseData }) => {
    let prompt = `You are an expert project manager helping to create a professional deliverable for a project.\n\n`;

    prompt += `PROJECT DETAILS:\n`;
    prompt += `- Project Name: ${projectData.name}\n`;
    prompt += `- Project Description: ${projectData.description || 'N/A'}\n`;
    if (projectData.clientName) {
        prompt += `- Client: ${projectData.clientName}\n`;
    }
    prompt += `\n`;

    if (phaseData) {
        prompt += `PHASE DETAILS:\n`;
        prompt += `- Phase Name: ${phaseData.name}\n`;
        prompt += `- Phase Description: ${phaseData.description || 'N/A'}\n`;
        if (phaseData.startDate) {
            prompt += `- Start Date: ${phaseData.startDate}\n`;
        }
        if (phaseData.endDate) {
            prompt += `- End Date: ${phaseData.endDate}\n`;
        }
        prompt += `\n`;
    }

    prompt += `DELIVERABLE TO CREATE:\n`;
    prompt += `- Deliverable Name: ${deliverableName}\n`;
    prompt += `- Deliverable Type: ${deliverableType}\n`;
    prompt += `\n`;

    if (templateContent) {
        prompt += `TEMPLATE STRUCTURE:\n`;
        prompt += `${templateContent}\n`;
        prompt += `\n`;
    }

    prompt += `INSTRUCTIONS:\n`;
    prompt += `Please generate a professional ${deliverableType} document for this deliverable. `;
    prompt += `Use the project and phase details provided above to create relevant and specific content. `;

    if (templateContent) {
        prompt += `Follow the template structure provided, filling in all sections with appropriate content based on the project details. `;
    }

    prompt += `The output should be well-formatted, professional, and ready for review by stakeholders. `;
    prompt += `Use markdown formatting for structure and readability.\n`;

    return prompt;
};

/**
 * Analyze if a deliverable can be generated by AI
 */
export const canGenerateWithAI = (deliverableType, templateContent) => {
    // List of deliverable types that are suitable for AI generation
    const aiSuitableTypes = [
        'status_report',
        'meeting_minutes',
        'project_summary',
        'risk_assessment',
        'requirements_document',
        'test_plan',
        'user_guide',
        'technical_documentation'
    ];

    const normalizedType = deliverableType.toLowerCase().replace(/\s+/g, '_');

    // Check if type is suitable and there's template content
    return aiSuitableTypes.includes(normalizedType) && !!templateContent;
};

/**
 * Generate multiple deliverables in batch
 */
export const generateBatchDeliverables = async (deliverablesData) => {
    const results = [];

    for (const deliverableData of deliverablesData) {
        try {
            const content = await generateDeliverable(deliverableData);
            results.push({
                success: true,
                deliverableId: deliverableData.deliverableId,
                content
            });
        } catch (error) {
            results.push({
                success: false,
                deliverableId: deliverableData.deliverableId,
                error: error.message
            });
        }
    }

    return results;
};

/**
 * Improve or refine existing deliverable content
 */
export const refineDeliverable = async (currentContent, refinementInstructions) => {
    try {
        const model = genAI.getGenerativeModel({ model: 'gemini-pro' });

        const prompt = `You are an expert editor helping to refine a project deliverable.\n\n`;
        prompt += `CURRENT CONTENT:\n${currentContent}\n\n`;
        prompt += `REFINEMENT INSTRUCTIONS:\n${refinementInstructions}\n\n`;
        prompt += `Please improve the content based on the instructions above. Maintain the overall structure and intent, but enhance clarity, professionalism, and completeness.`;

        const result = await model.generateContent(prompt);
        const response = await result.response;
        const refinedText = response.text();

        return refinedText;
    } catch (error) {
        console.error('AI refinement error:', error);
        throw new Error(`Failed to refine deliverable: ${error.message}`);
    }
};

export default {
    generateDeliverable,
    canGenerateWithAI,
    generateBatchDeliverables,
    refineDeliverable
};
